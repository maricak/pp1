

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());   

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }      
  	public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska: ", cur_token);
    }	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("\nFatalna greska, parsiranje ne moze da se nastavi: ", cur_token);
    }      
    public void report_error(String message, Object info) {
		errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append("'").append(((Symbol)info).value).append("' na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }  
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
        	msg.append("'").append(((Symbol)info).value).append("' na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal INT, BOOL, CHAR;
terminal NULL;
terminal ADD, SUBTRACT, MULTIPLY, DIVIDE, MODULO;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR;
terminal ASSIGN;
terminal INCREMENT, DECREMENT;
terminal SEPARATOR, COMMA, POINT;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal PROGRAM, CLASS, EXTENDS, INTERFACE, IMPLEMENTS, ENUM, IF, ELSE, NEW, FOR, RETURN, BREAK, CONTINUE, PRINT, READ, VOID, CONST;
terminal CHR, ORD, LEN;
terminal Integer INT_VALUE;
terminal Integer CHAR_VALUE;
terminal Integer BOOL_VALUE;
terminal String IDENTIFIER;
terminal ERROR;

nonterminal Program, DeclList, Decl, ConstDecl, AssignConstList, EnumDecl, OptionalAssignNum, AssignNum;
nonterminal IdentOptionalAssignNumList, VarDecl, VarList, ClassDecl, OptionalExtendsType, ClassVarDeclList;
nonterminal InterfaceImplList, InterfaceList, OptionalMethodDeclList, MethodDeclList, InterfaceDecl, InterfaceMethodDeclList, InterfaceMethodDecl;
nonterminal MethodDecl, OptionalBrackets, VarDeclList, FormPars, FormPar, Statement, IfStatement, AssignConst;
nonterminal OptionalElse, ForStatement, OptionalCondition, OptionalDesignatorStatement, OptionalExpr, PrintNumParameter, StatementList, DesignatorStatement;
nonterminal ActPars, Condition, OrCondFactList, CondTerm, AndCondFactList, CondFact, OptionalRelopExpr; 
nonterminal Assignop, Relop, Addop, Mulop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramStart, MethodStart, Designator, StandardFunction;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ClassStart, Factor, Expr, Term, Type, ReturnType;
nonterminal rs.ac.bg.etf.pp1.mysymboltable.Constant ConstValue;
nonterminal rs.ac.bg.etf.pp1.mysymboltable.Variable VarName;

precedence left ELSE;

Program ::= (Program) ProgramStart DeclList LEFT_BRACE MethodDeclList RIGHT_BRACE
        ;

ProgramStart ::= (ProgramStart) PROGRAM IDENTIFIER:programName
                ;

DeclList ::= (DeclarationList) DeclList Decl
			| (DeclarationListNO) /*epsilon */
            ;

Decl ::= (Declaration) ConstDecl
        | (DeclarationVar) VarDecl
        | (DeclarationClass) ClassDecl
        | (DeclarationEnum) EnumDecl
        | (DeclarationInterface) InterfaceDecl
        ;	

ConstDecl ::= (ConstDecl) CONST Type:constType AssignConstList SEPARATOR
            ; 
			
AssignConstList ::= (AssignConstantList) AssignConstList COMMA AssignConst
				| (AssignConstantListEnd) AssignConst
                ;
	
AssignConst ::= (AssignConst)  IDENTIFIER:constName ASSIGN ConstValue:constValue
            ;					

ConstValue ::= (ConstValueInt) INT_VALUE:value 
			| (ConstValueChar) CHAR_VALUE:value 
			| (ConstValueBool) BOOL_VALUE:value
            ;

EnumDecl ::= (EnumDecl) ENUM IDENTIFIER LEFT_BRACE IDENTIFIER OptionalAssignNum IdentOptionalAssignNumList RIGHT_BRACE
            ;

OptionalAssignNum ::= (OptionalAssgnNumberClass) AssignNum
					| (NoOptionalAssgnNumberClass) /* epsilon */
                    ;					
					
AssignNum ::= (AssignNum) ASSIGN INT_VALUE
            ;


IdentOptionalAssignNumList ::= (IdentifierOptionalAssignNumberListClass) IdentOptionalAssignNumList COMMA IDENTIFIER OptionalAssignNum
							| (NoIdentifierOptionalAssignNumberListClass) /* epsilon */
                            ;

VarDecl ::= (VarDecl) Type:varType VarList SEPARATOR
        ;
		
VarList ::= (VariableList) VarList COMMA VarName
			| (VariableListEnd) VarName /* epsilon */
            ;
			
VarName ::= (VarName) IDENTIFIER:varName OptionalBrackets:brackets
        ;

ClassDecl ::= (ClassDecl) ClassStart OptionalExtendsType InterfaceImplList LEFT_BRACE ClassVarDeclList OptionalMethodDeclList RIGHT_BRACE
            ;

ClassVarDeclList ::= (ClassVarDeclList) VarDeclList
                ;

ClassStart ::= (ClassStart) CLASS IDENTIFIER:className
            ;
			
OptionalExtendsType ::= (ExtendsType) EXTENDS Type:type
					| (ExtendsTypeNO) /* epsilon */
					;					

InterfaceImplList ::= (InterfaceImplementsList) IMPLEMENTS InterfaceList
                    | (InterfaceImplementsListNO) /* epsilon */
                    ;
            
InterfaceList ::= (Interfaces) InterfaceList COMMA Type:type
                | (Interface) Type:type
                | (InterfacesNO) /* epsilon */
                ;
			
OptionalMethodDeclList ::= (OptionalMethodDeclarationListClass) LEFT_BRACE MethodDeclList RIGHT_BRACE
						| (NoOptionalMethodDeclarationListClass) /* epsilon */
						;
								
MethodDeclList ::= (MethodDeclarationListClass) MethodDeclList MethodDecl
			| (NoMethodDeclarationListClass)/* epsilon */
			;


InterfaceDecl ::= (InterfaceDeclarationClass) INTERFACE IDENTIFIER LEFT_BRACE InterfaceMethodDeclList RIGHT_BRACE
				;

InterfaceMethodDeclList ::= (InterfaceMethodDeclListClass) InterfaceMethodDeclList InterfaceMethodDecl
						| (NoInterfaceMethodDeclListClass) /* epsilon */
						;

InterfaceMethodDecl ::= (InterfaceMethodDeclarationClass) ReturnType IDENTIFIER LEFT_PARENTHESIS FormPars RIGHT_PARENTHESIS SEPARATOR
					;

MethodDecl ::= (MethodDecl) MethodStart LEFT_PARENTHESIS FormPars RIGHT_PARENTHESIS VarDeclList LEFT_BRACE StatementList RIGHT_BRACE
			;

MethodStart ::= (MethodStart) ReturnType IDENTIFIER:methodName
			;
	
ReturnType ::= (ReturnT) Type
			| (ReturnVoid) VOID
			;
			
FormPars ::= (FormalParameters) FormPars COMMA FormPar				
			| (FormalParameter) FormPar
			| (FormalParametersNO)	/* epsilon */
			;


VarDeclList ::= (VariableDeclList) VarDeclList VarDecl
			| (VariableDeclListNO) /* epsilon */
			;
				
FormPar ::= (FormPar) Type VarName 
			;
			
OptionalBrackets ::= (Brackets) LEFT_BRACKET RIGHT_BRACKET
				| (BracketsNO) /* epsilon */
				;

Type ::= (TypeInt) INT
		| (TypeBool) BOOL
		| (TypeChar) CHAR
		| (TypeCustom) IDENTIFIER:typeName
		;

StandardFunction ::= (StandardFunctionChr) CHR LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
                    | (StandardFunctionOrd) ORD LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
                    | (StandardFunctionLen) LEN LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
                    ;

Statement ::= (StatementDesignator) DesignatorStatement SEPARATOR
			| (StatementIf) IfStatement 
			| (StatementFor) ForStatement
			| (StatementBreak) BREAK SEPARATOR
			| (StatementContinue) CONTINUE SEPARATOR
			| (StatementReturn) RETURN SEPARATOR
			| (StatementReturnExpr) RETURN Expr SEPARATOR
			| (StatementRead) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEPARATOR
			| (StatementPrint) PRINT LEFT_PARENTHESIS Expr PrintNumParameter RIGHT_PARENTHESIS SEPARATOR
			| (StatementBlock) LEFT_BRACE StatementList RIGHT_BRACE
			;

IfStatement ::=  (IfStatementClass) IF LEFT_PARENTHESIS Condition RIGHT_PARENTHESIS Statement OptionalElse
			;
		
OptionalElse ::= (OptionalElseClass) ELSE Statement
				| (NoOptionalElseClass) /* epsilon */
				;
			
ForStatement ::= (ForStatementClass) FOR LEFT_PARENTHESIS OptionalDesignatorStatement SEPARATOR OptionalCondition SEPARATOR OptionalDesignatorStatement RIGHT_PARENTHESIS Statement
			;
			
OptionalCondition ::= (OptionalConditionClass) Condition 
					| (NoOptionalConditionClass) /* epsilon */
					;
			
OptionalDesignatorStatement ::= (OptionalDesignatorStatementClass) DesignatorStatement
							| (NoOptionalDesignatorStatementClass) /* epsilon */
							;
	
PrintNumParameter ::= (PrintNumberParameter) COMMA INT_VALUE
                | (PrintNumberParameterNO) /* espilon */
                ;		
			
StatementList ::= (Statements) StatementList Statement
				| (StatementsNO) /* epsilon */
				;

DesignatorStatement ::= (DesignatorAssign) Designator Assignop Expr
                    | (DesignatorStandardFunction) StandardFunction
                    | (DesignatorFunctionCall) Designator LEFT_PARENTHESIS ActPars RIGHT_PARENTHESIS
                    | (DesignatorIncrement) Designator INCREMENT
                    | (DesignatorDecrement) Designator DECREMENT
					;		

ActPars ::= (ActParameter) Expr
        | (ActParameters) ActPars COMMA Expr
        | (ActParametersNO) /* epsilon */
		;
		
Condition ::= (ConditionClass) CondTerm OrCondFactList
			;
			
OrCondFactList ::= (OrConditionFactListClass) OrCondFactList OR CondFact
				| (NoOrConditionFactListClass) /* epsilon */
				;				

CondTerm ::= (ConditionTermClass) CondFact AndCondFactList
			;
			
AndCondFactList ::= (AndConditionFactListClass) AndCondFactList AND CondFact
				| (NoAndConditionFactListClass) /* epsilon */
				;	

CondFact ::= (ConditionFactClass) Expr OptionalRelopExpr
		;
		
OptionalRelopExpr ::= (OptionalRelopExprClassClass) Relop Expr
					| (NoOptionalRelopExprClassClass) /* epsilon */
					;

Expr ::= (ExprTerm) Term
        | (ExprNegativeTerm) SUBTRACT Term
        | (ExprAddop) Expr Addop Term
		;		

Term ::= (TermFactor) Factor 
        | (TermMulop) Term Mulop Factor
		;			

Factor ::= (FactorDesignator) Designator
        | (FactorStandardFunction) StandardFunction
        | (FactorFunctionCall) Designator LEFT_PARENTHESIS ActPars RIGHT_PARENTHESIS
		| (FactorConst) ConstValue	
		| (FactorNewObj) NEW Type
        | (FactorNewArray) NEW Type LEFT_BRACKET Expr RIGHT_BRACKET
		| (FactorNull) NULL
		| (FactorExpression) LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
		;		
					
Designator ::= (DesignatorName) IDENTIFIER:name
            | (DesignatorPointAccess) Designator POINT IDENTIFIER:name
            | (DesignatorArrayAccess) Designator LEFT_BRACKET Expr RIGHT_BRACKET
            ;

Assignop ::= (Assignop) ASSIGN 	
			;

Relop ::= (Equal) EQUAL
		| (NotEqual) NOT_EQUAL
		| (Greater) GREATER
		| (GreaterEqual) GREATER_EQUAL
		| (Less) LESS
		| (LessEqual) LESS_EQUAL
		;

Addop ::= (Add) ADD
		| (Subtract) SUBTRACT
		;

Mulop ::= (Multiplie) MULTIPLY 
		| (Divide) DIVIDE
		| (Modulo) MODULO
		;


