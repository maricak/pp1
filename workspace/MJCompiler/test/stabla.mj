program Programcic123

// klasa za pakovanje nizova
// posto ne mozemo da imamo niz kao povratnu vrednost (po gramatici)
class PackedCharArray
{
	char array[];
}

// gomila interfejsa, za testiranje visestruke implementacije
interface IUtil
{
	void printstr(char str[]);
}
interface IBuilder
{
	PackedCharArray buildIma();	
}
interface IBuilder2
{
	PackedCharArray buildNema();	
}

// glob. promenljiva
IBuilder builder1;


class Util implements IBuilder, IBuilder2
{
	{
		// kreira string "Nema" i vraca ga
		PackedCharArray buildIma()
		PackedCharArray pca;
		char nizchar[];
		{
			nizchar=new char[3];
			nizchar[0]='I';
			nizchar[1]='m';
			nizchar[2]='a';
			pca=new PackedCharArray;
			pca.array=nizchar;
			return pca;
		}
		// vraca null, bice nadjacana dole
		PackedCharArray buildNema()
		{
			return null;
		}
	}
}
IBuilder2 builder2;
class Util2 extends Util implements IUtil
{
	{
		// ispisuje string
		void printstr(char str[])
		int i;
		{
			for(i=0;i<len(str);i++) print(str[i]);
		}
		
		// nadjacana odozgo, vraca string "Ima"
		PackedCharArray buildNema()
		PackedCharArray pca;
		char nizchar[];
		{
			nizchar=new char[4];
			nizchar[0]='N';
			nizchar[1]='e';
			nizchar[2]='m';
			nizchar[3]='a';
			pca=new PackedCharArray;
			pca.array=nizchar;
			return pca;
		}
	}
}
IUtil util;


// cvor stabla
class Node
{
	Node right, left;
	int val;
	{
		// rekurzivni insert
		void insrt(int v)
		{
			if(v>val)
			{
				if(right==null)
				{
					right=new Node;
					right.val=v;
				}
				else
				{
					right.insrt(v);
				}
			}
			else
			{
				if(left==null)
				{
					left=new Node;
					left.val=v;
				}
				else
				{
					left.insrt(v);
				}
			}
		}
	}
}

PackedCharArray ima;
PackedCharArray nema;

enum StringPicker{IMA=42, NEMA=43}
    

{
	// ispisuje string zadat enumom
	void printstr(int x)
	{
		if(x==42 && x==StringPicker.IMA) util.printstr(ima.array);
		if(x==86 || x==StringPicker.NEMA) util.printstr(nema.array);
	}
	// ispisuje string zadat enumom	
	void printstrE(StringPicker e)
	{
		if(e>=42 && e<=43) printstr(e);
	}
	// pretraga stabla
	bool find(Node nd, int v)
	{
		if(nd!=null && nd.val==v) return true;
		else if(nd!=null && nd.val<v) return find(nd.right, v);
		else if(nd!=null && nd.val>v) 
		{
			return find(nd.left, v);
		}
		else return false;
	}
	// vraca pocetnu poruku
	PackedCharArray getInitialMessage()
	PackedCharArray pca;
	char nizchar[];
	{
		nizchar=new char[80];
		nizchar[0]='U';
		nizchar[1]='n';
		nizchar[2]='e';
		nizchar[3]='s';
		nizchar[4]='i';
		nizchar[5]='t';
		nizchar[6]='e';
		nizchar[7]=' ';
		nizchar[8]='k';
		nizchar[9]='o';
		nizchar[10]='m';
		nizchar[11]='a';
		nizchar[12]='n';
		nizchar[13]='d';
		nizchar[14]='u';
		nizchar[15]=':';
		nizchar[16]=eol;
		nizchar[17]='1';
		nizchar[18]=' ';
		nizchar[19]='X';
		nizchar[20]=' ';
		nizchar[21]='(';
		nizchar[22]='u';
		nizchar[23]='b';
		nizchar[24]='a';
		nizchar[25]='c';
		nizchar[26]='i';
		nizchar[27]='v';
		nizchar[28]='a';
		nizchar[29]='n';
		nizchar[30]='j';
		nizchar[31]='e';
		nizchar[32]=' ';
		nizchar[33]='e';
		nizchar[34]='l';
		nizchar[35]='e';
		nizchar[36]='m';
		nizchar[37]='e';
		nizchar[38]='n';
		nizchar[39]='t';
		nizchar[40]='a';
		nizchar[41]=' ';
		nizchar[42]='X';
		nizchar[43]=' ';
		nizchar[44]='u';
		nizchar[45]=' ';
		nizchar[46]='s';
		nizchar[47]='t';
		nizchar[48]='a';
		nizchar[49]='b';
		nizchar[50]='l';
		nizchar[51]='o';
		nizchar[52]=')';
		nizchar[53]=eol;
		nizchar[54]='2';
		nizchar[55]=' ';
		nizchar[56]='X';
		nizchar[57]=' ';
		nizchar[58]='p';
		nizchar[59]='r';
		nizchar[60]='e';
		nizchar[61]='t';
		nizchar[62]='r';
		nizchar[63]='a';
		nizchar[64]='g';
		nizchar[65]='a';
		nizchar[66]=' ';
		nizchar[67]='s';
		nizchar[68]='t';
		nizchar[69]='a';
		nizchar[70]='b';
		nizchar[71]='l';
		nizchar[72]='a';
		nizchar[73]=eol;
		nizchar[74]='3';
		nizchar[75]=' ';
		nizchar[76]='K';
		nizchar[77]='r';
		nizchar[78]='a';
		nizchar[79]='j';
		pca=new PackedCharArray;
		pca.array=nizchar;
		return pca;
	}
    void main()
    PackedCharArray message;
    Node root;
    int c, v;
    {
    	util=new Util2;
    	builder1=new Util2;
    	builder2=new Util2;
    	message = getInitialMessage();
    	ima=builder1.buildIma();
    	nema=builder2.buildNema();
    	util.printstr(message.array);
    	root=null;
    	read(c);
    	for(;c!=3;)
    	{
    		if(c==1)
    		{
    			read(v);
    			if(root==null)
    			{
    				root=new Node;
    				root.val=v;
    			}
    			else
    			{
    				root.insrt(v);
    			}
    		}
    		else if(c==2)
    		{
    			read(v);
    			if(find(root, v))
    			{
    				printstrE(StringPicker.IMA);
    			}else printstr(StringPicker.NEMA);
    		}
    		read(c);
    	}
    }
}
