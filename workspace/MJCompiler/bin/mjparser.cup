

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;
	
    int line = -1;
    String type = "";

	Logger log = Logger.getLogger(getClass());   

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }      
  	public void syntax_error(Symbol cur_token) {
        line = cur_token.left;
        report_error("Sintaksna greska: ", cur_token);
    }	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje ne moze da se nastavi: ", cur_token);
    }      
    public void report_error(String message, Object info) {
		errorDetected = true;
    	StringBuilder msg = new StringBuilder("[GRESKA! ");
        msg.append(message);
        if (info instanceof Symbol)
            msg.append("'").append(((Symbol)info).value).append("' na liniji ").append(((Symbol)info).left);
        else if(info == null) {
            msg.append(" " + type + " ");
            msg.append("na liniji " + line);
        }
        msg.append("]");
        log.error(msg.toString());
    }  
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
        	msg.append("'").append(((Symbol)info).value).append("' na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal INT, BOOL, CHAR;
terminal NULL;
terminal ADD, SUBTRACT, MULTIPLY, DIVIDE, MODULO;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR;
terminal ASSIGN;
terminal INCREMENT, DECREMENT;
terminal SEPARATOR, COMMA, POINT;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal PROGRAM, CLASS, EXTENDS, INTERFACE, IMPLEMENTS, ENUM, IF, ELSE, NEW, FOR, RETURN, BREAK, CONTINUE, PRINT, READ, VOID, CONST;
terminal CHR, ORD, LEN;
terminal Integer INT_VALUE;
terminal Integer CHAR_VALUE;
terminal Integer BOOL_VALUE;
terminal String IDENTIFIER;

nonterminal Program, DeclList, Decl, ConstDecl, AssignConstList, EnumDecl, OptionalAssignNum, AssignNum;
nonterminal IdentOptionalAssignNumList, VarDecl, VarList, ClassDecl, Extends, ClassVarDeclList;
nonterminal Implements, InterfaceList, OptionalMethodDeclList, MethodDeclList, InterfaceDecl, InterfaceMethodDeclList, InterfaceMethodDecl;
nonterminal MethodDecl, OptionalBrackets, VarDeclList, FormPars, FormPar, Statement, IfStatement, AssignConst;
nonterminal OptionalElse, ForStatement, OptionalCondition, OptionalDesignatorStatement, PrintNumParameter, StatementList, DesignatorStatement;
nonterminal ActPars, Condition, OrCondFactList, CondTerm, AndCondFactList, CondFact, OptionalRelopExpr; 
nonterminal Assignop, Relop, Addop, Mulop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramStart, MethodStart, Designator, StandardFunction;
nonterminal rs.etf.pp1.symboltable.concepts.Struct ClassStart, Factor, Expr, Term, Type, ReturnType;
nonterminal rs.ac.bg.etf.pp1.mysymboltable.Constant ConstValue;
nonterminal rs.ac.bg.etf.pp1.mysymboltable.Variable VarName;

precedence left ELSE;

Program ::= (Program) ProgramStart DeclList LEFT_BRACE MethodDeclList RIGHT_BRACE
          ;

ProgramStart ::= (ProgramStart) {: parser.type = "globalne promenljive"; :} PROGRAM IDENTIFIER:programName                 
               ;

DeclList ::= (DeclarationList) DeclList Decl
		   | (DeclarationListNO) /*epsilon */
           ;

Decl ::= (DeclarationConst) ConstDecl
       | (DeclarationVar) VarDecl
       | (DeclarationClass) ClassDecl
       | (DeclarationEnum) EnumDecl
       | (DeclarationInterface) InterfaceDecl
       ;	

ConstDecl ::= (ConstantDecl) CONST Type AssignConstList SEPARATOR
            | (ConstantDeclERR) CONST error SEPARATOR 
              {: parser.report_error("OPORAVAK Sintasna greska prilikom definisanja konstante", null); :}
            ; 
			
AssignConstList ::= (AssignConstantList) AssignConstList COMMA AssignConst
				  | (AssignConstantListEnd) AssignConst
                  ;
	
AssignConst ::= (AssignConstant)  IDENTIFIER:constName ASSIGN ConstValue:constValue
              | (AssignConstantERR) error 
                {: parser.report_error("OPORAVAK Sintasna greska prilikom definisanja konstante", null); :}
              ;					

ConstValue ::= (ConstValueInt) INT_VALUE:value 
			 | (ConstValueChar) CHAR_VALUE:value 
			 | (ConstValueBool) BOOL_VALUE:value
             ;

EnumDecl ::= (EnumDecl) ENUM IDENTIFIER LEFT_BRACE IDENTIFIER OptionalAssignNum IdentOptionalAssignNumList RIGHT_BRACE
           ;

OptionalAssignNum ::= (OptionalAssgnNumberClass) AssignNum
					| (NoOptionalAssgnNumberClass) /* epsilon */
                    ;					
					
AssignNum ::= (AssignNum) ASSIGN INT_VALUE
            ;


IdentOptionalAssignNumList ::= (IdentifierOptionalAssignNumberListClass) IdentOptionalAssignNumList COMMA IDENTIFIER OptionalAssignNum
							 | (NoIdentifierOptionalAssignNumberListClass) /* epsilon */
                             ;

VarDecl ::= (VariableDecl) Type VarList SEPARATOR
          | (VariableDeclERR) error SEPARATOR 
            {: parser.report_error("OPORAVAK Sintasna greska prilikom deklarisanja", null); :}
          ;
		
VarList ::= (VariableList) VarList COMMA VarName
          | (VariableListEnd) VarName 
          ;
			
VarName ::= (VariableName) IDENTIFIER:varName OptionalBrackets:brackets      
          | (VariableNameERR) error 
            {: parser.report_error("OPORAVAK Sintasna greska prilikom deklarisanja", null); :}
          | (VariableNameEmptyERR) /* epsilon */ 
            {: parser.report_error("OPORAVAK Sintasna greska prilikom deklarisanja", null); :}
		  ;

ClassDecl ::= (ClassDecl) ClassStart Extends Implements LEFT_BRACE ClassVarDeclList OptionalMethodDeclList RIGHT_BRACE
            ;

ClassStart ::= (ClassStart) {: parser.type = "polja klase"; :} CLASS IDENTIFIER:className               
             ;
			
ClassVarDeclList ::= (ClassVarDeclList) VarDeclList
                   ;

Extends ::= (ExtendsType) EXTENDS Type
          //| (ExtendsERR) EXTENDS error {: parser.report_error("OPORAVAK Greska kod prosirivanja klase tip", new Object()); :}
          | (ExtendsERR) error {: parser.report_error("OPORAVAK Greska kod prosirivanja klase", new Object()); :}
          | (ExtendsTypeNO) /* epsilon */
          ;					

Implements ::= (ImplementsList) IMPLEMENTS InterfaceList
             | (ImplementsListNO) /* epsilon */
             ;
            
InterfaceList ::= (Interfaces) InterfaceList COMMA Type
                | (Interface) Type
                | (InterfacesNO) /* epsilon */
                ;
			
OptionalMethodDeclList ::= (OptionalMethodDeclarationList) LEFT_BRACE MethodDeclList RIGHT_BRACE
						 | (OptionalMethodDeclarationListNO) /* epsilon */
						 ;
								
MethodDeclList ::= (MethodDeclarationListClass) MethodDeclList MethodDecl
			     | (NoMethodDeclarationListClass)/* epsilon */
			     ;

InterfaceDecl ::= (InterfaceDeclarationClass) INTERFACE IDENTIFIER LEFT_BRACE InterfaceMethodDeclList RIGHT_BRACE
				;

InterfaceMethodDeclList ::= (InterfaceMethodDeclListClass) InterfaceMethodDeclList InterfaceMethodDecl
						  | (NoInterfaceMethodDeclListClass) /* epsilon */
						  ;

InterfaceMethodDecl ::= (InterfaceMethodDeclarationClass) ReturnType IDENTIFIER LEFT_PARENTHESIS FormPars RIGHT_PARENTHESIS SEPARATOR
					  ;

MethodDecl ::= (MethodDecl) MethodStart LEFT_PARENTHESIS FormPars RIGHT_PARENTHESIS {: parser.type = "lokalne promenljive"; :} VarDeclList LEFT_BRACE StatementList RIGHT_BRACE
             ;

MethodStart ::= (MethodStart) {: parser.type = "formalnog parametra"; :} ReturnType IDENTIFIER:methodName                
			  ;
	
ReturnType ::= (ReturnT) Type
			 | (ReturnVoid) VOID
			 ;
			
FormPars ::= (FormalParameters) FormPars COMMA FormPar           
		   | (FormalParameter) FormPar
		   | (FormalParametersNO)	/* epsilon */
		   ;

FormPar ::= (FormPar) Type VarName 
		  ;

VarDeclList ::= (VariableDeclList) VarDeclList VarDecl
			  | (VariableDeclListNO) /* epsilon */
			  ;	
			
OptionalBrackets ::= (Brackets) LEFT_BRACKET RIGHT_BRACKET
				   | (BracketsNO) /* epsilon */
				   ;

Type ::= (TypeInt) INT
	   | (TypeBool) BOOL
	   | (TypeChar) CHAR
       | (TypeCustom) IDENTIFIER:typeName
	   ;

StandardFunction ::= (StandardFunctionChr) CHR LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
                   | (StandardFunctionOrd) ORD LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
                   | (StandardFunctionLen) LEN LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
                   ;

Statement ::= (StatementDesignator) DesignatorStatement
			| (StatementIf) IfStatement 
			| (StatementFor) ForStatement
			| (StatementBreak) BREAK SEPARATOR
			| (StatementContinue) CONTINUE SEPARATOR
			| (StatementReturn) RETURN SEPARATOR
			| (StatementReturnExpr) RETURN Expr SEPARATOR
			| (StatementRead) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEPARATOR
			| (StatementPrint) PRINT LEFT_PARENTHESIS Expr PrintNumParameter RIGHT_PARENTHESIS SEPARATOR
			| (StatementBlock) LEFT_BRACE StatementList RIGHT_BRACE
			;

IfStatement ::= (IfStatement) IF LEFT_PARENTHESIS Condition RIGHT_PARENTHESIS Statement OptionalElse
            //| (IfStatementERR) IF LEFT_PARENTHESIS error RIGHT_PARENTHESIS Statement OptionalElse:e {:parser.report_error("Sintaksna greska unutar if konstrukcije", lleft); :}
            //| (IfStatementEmptyERR) IF LEFT_PARENTHESIS /* epsilon */ RIGHT_PARENTHESIS Statement OptionalElse:e {:parser.report_error("Sintaksna greska unutar if konstrukcije", lleft); :}
			  ;
		
OptionalElse ::= (OptionalElseClass) ELSE Statement
			   | (NoOptionalElseClass) /* epsilon */
			   ;
			
ForStatement ::= (ForStatementClass) FOR LEFT_PARENTHESIS OptionalDesignatorStatement SEPARATOR OptionalCondition SEPARATOR OptionalDesignatorStatement RIGHT_PARENTHESIS Statement
			   ;
			
OptionalCondition ::= (OptionalConditionClass) Condition 
					| (NoOptionalConditionClass) /* epsilon */
					;
			
OptionalDesignatorStatement ::= (OptionalDesignatorStatementClass) DesignatorStatement
							  | (NoOptionalDesignatorStatementClass) /* epsilon */
							  ;
	
PrintNumParameter ::= (PrintNumberParameter) COMMA INT_VALUE
                    | (PrintNumberParameterNO) /* espilon */
                    ;		
			
StatementList ::= (Statements) StatementList Statement
				| (StatementsNO) /* epsilon */
				;

DesignatorStatement ::= (DesignatorAssign) Designator Assignop Expr SEPARATOR
                      | (DesignatorStandardFunction) StandardFunction SEPARATOR
                      | (DesignatorFunctionCall) Designator LEFT_PARENTHESIS ActPars RIGHT_PARENTHESIS SEPARATOR
                      | (DesignatorIncrement) Designator INCREMENT SEPARATOR
                      | (DesignatorDecrement) Designator DECREMENT SEPARATOR
					  ;		

ActPars ::= (ActParameter) Expr
          | (ActParameters) ActPars COMMA Expr
          | (ActParametersNO) /* epsilon */
		  ;
		
Condition ::= (ConditionClass) CondTerm OrCondFactList
			;
			
OrCondFactList ::= (OrConditionFactListClass) OrCondFactList OR CondFact
				 | (NoOrConditionFactListClass) /* epsilon */
				 ;				

CondTerm ::= (ConditionTermClass) CondFact AndCondFactList
		   ;
			
AndCondFactList ::= (AndConditionFactListClass) AndCondFactList AND CondFact
				  | (NoAndConditionFactListClass) /* epsilon */
				  ;	

CondFact ::= (ConditionFactClass) Expr OptionalRelopExpr
		   ;
		
OptionalRelopExpr ::= (OptionalRelopExprClassClass) Relop Expr
					| (NoOptionalRelopExprClassClass) /* epsilon */
					;

Expr ::= (ExprTerm) Term
       | (ExprNegativeTerm) SUBTRACT Term
       | (ExprAddop) Expr Addop Term
       | (ExprERR) error 
         {: parser.report_error("OPORAVAK Sintaksna greska EXPR ", null); :}
	   ;		

Term ::= (TermFactor) Factor 
       | (TermMulop) Term Mulop Factor
	   ;			

Factor ::= (FactorDesignator) Designator
         | (FactorStandardFunction) StandardFunction
         | (FactorFunctionCall) Designator LEFT_PARENTHESIS ActPars RIGHT_PARENTHESIS
		 | (FactorConst) ConstValue	
		 | (FactorNewObj) NEW Type
         | (FactorNewArray) NEW Type LEFT_BRACKET Expr RIGHT_BRACKET
		 | (FactorNull) NULL
		 | (FactorExpression) LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
		 ;		
					
Designator ::= (DesignatorName) IDENTIFIER:name
             | (DesignatorPointAccess) Designator POINT IDENTIFIER:name
             | (DesignatorArrayAccess) Designator LEFT_BRACKET Expr RIGHT_BRACKET
             ;

Assignop ::= (Assignop) ASSIGN 	
		   ;

Relop ::= (Equal) EQUAL
		| (NotEqual) NOT_EQUAL
		| (Greater) GREATER
		| (GreaterEqual) GREATER_EQUAL
		| (Less) LESS
		| (LessEqual) LESS_EQUAL
		;

Addop ::= (Add) ADD
		| (Subtract) SUBTRACT
		;

Mulop ::= (Multiplie) MULTIPLY 
		| (Divide) DIVIDE
		| (Modulo) MODULO
		;


