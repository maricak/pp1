

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());   

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }      
  	public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska: ", cur_token);
    }	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("\nFatalna greska, parsiranje ne moze da se nastavi: ", cur_token);
    }      
    public void report_error(String message, Object info) {
		errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append("'").append(((Symbol)info).value).append("' na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }  
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
        	msg.append("'").append(((Symbol)info).value).append("' na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal INT, BOOL, CHAR;
terminal NULL;
terminal ADD, SUBTRACT, MULTIPLY, DIVIDE, MODULO;
terminal EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
terminal AND, OR;
terminal ASSIGN;
terminal INCREMENT, DECREMENT;
terminal SEPARATOR, COMMA, POINT;
terminal LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LEFT_BRACKET, RIGHT_BRACKET, LEFT_BRACE, RIGHT_BRACE;
terminal PROGRAM, CLASS, EXTENDS, INTERFACE, IMPLEMENTS, ENUM, IF, ELSE, NEW, FOR, RETURN, BREAK, CONTINUE, PRINT, READ, VOID, CONST;
terminal CHR, ORD, LEN;
terminal Integer INT_VALUE;
terminal Integer CHAR_VALUE;
terminal Integer BOOL_VALUE;
terminal String IDENTIFIER;
terminal ERROR;

nonterminal Program, DeclList, Decl, ConstDecl, AssignConstList, EnumDecl, OptionalAssignNum, AssignNum;
nonterminal IdentOptionalAssignNumList, VarDecl, VarList, ClassDecl, OptionalExtendsType, ExtendsType, OptionalImplementsTypeList;
nonterminal ImplementsTypeList, TypeList, OptionalMethodDeclList, MethodDeclList, InterfaceDecl, InterfaceMethodDeclList, InterfaceMethodDecl;
nonterminal MethodDecl, ReturnType, OptionalBrackets, OptionalFormPars, VarDeclList, FormPars, TypeIdentBracketsList, Statement, IfStatement; 
nonterminal OptionalElse, ForStatement, OptionalCondition, OptionalDesignatorStatement, OptionalExpr, OptionalCommaNumConst, StatementList, DesignatorStatement;
nonterminal DesignatorStatementOption, ActPars, ExprList, Condition, OrCondFactList, CondTerm, AndCondFactList, CondFact, OptionalRelopExpr, Expr, OptionalMinus; 
nonterminal AddopTermList, Term, MulopFactorList, Factor, DesignatorFactor, OptionalDesignatorCallParams, DesignatorCallParams, OptionalActPars, NewFactor;
nonterminal OptionalArraySelector, Designator, DesignatorSelectorList, DesignatorSelector, PointSelector, ArraySelector, Assignop, Relop, Addop, Mulop;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Type;
nonterminal rs.ac.bg.etf.pp1.mysymboltable.Constant ConstValue;
nonterminal rs.ac.bg.etf.pp1.mysymboltable.Variable VarName;

precedence left ELSE;

Program ::= (Program) PROGRAM IDENTIFIER DeclList LEFT_BRACE MethodDeclList RIGHT_BRACE
		;

DeclList ::= (DeclarationList) DeclList Decl
			|
			(DeclarationListNO) /* epsilon */
			;

Decl ::= (Declaration) ConstDecl
				|
				(DeclarationVar) VarDecl
				|
				(DeclarationClass) ClassDecl
				|
				(DeclarationEnum) EnumDecl
				|
				(DeclarationInterface) InterfaceDecl
				;	

ConstDecl ::= (ConstDecl) CONST Type:constType AssignConstList SEPARATOR
			;
			
AssignConstList ::= (AssignConstantList) AssignConstList COMMA IDENTIFIER:constName ASSIGN ConstValue:constValue
				|
				(AssignConstantListEnd) IDENTIFIER:constName ASSIGN ConstValue:constValue /* epsilon */
				;
								

ConstValue ::= (ConstValueInt) INT_VALUE:value 
			|
			(ConstValueChar) CHAR_VALUE:value 
			|
			(ConstValueBool) BOOL_VALUE:value 
			;

EnumDecl ::= (EnumDecl) ENUM IDENTIFIER LEFT_BRACE IDENTIFIER OptionalAssignNum IdentOptionalAssignNumList RIGHT_BRACE
			;

OptionalAssignNum ::= (OptionalAssgnNumberClass) AssignNum
					|
					(NoOptionalAssgnNumberClass) /* epsilon */
					;					
					
AssignNum ::= (AssignNum) ASSIGN INT_VALUE
			;


IdentOptionalAssignNumList ::= (IdentifierOptionalAssignNumberListClass) IdentOptionalAssignNumList COMMA IDENTIFIER OptionalAssignNum
							|
							(NoIdentifierOptionalAssignNumberListClass) /* epsilon */
							;

VarDecl ::= (VarDecl) Type:varType VarList SEPARATOR
		;
		
VarList ::= (VariableList) VarList COMMA VarName
			|
			(VariableListEnd) VarName /* epsilon */
			;
			
VarName ::= (VarName) IDENTIFIER:varName OptionalBrackets:brackets
		;

ClassDecl ::= (ClassDecl) CLASS IDENTIFIER OptionalExtendsType OptionalImplementsTypeList LEFT_BRACE VarDeclList:declList OptionalMethodDeclList RIGHT_BRACE
			;
			
OptionalExtendsType ::= (OptionalExtendsTypeClass) ExtendsType
					|
					(NoOptionalExtendsTypeClass) /* epsilon */
					;
		
ExtendsType ::= (ExtendsTypeClass) EXTENDS Type
			;
			
OptionalImplementsTypeList ::= (OptionalImplementsTypeListClass) ImplementsTypeList
							|
							(NoOptionalImplementsTypeListClass) /* epsilon */
							;
							

ImplementsTypeList ::= (ImplementsTypeListClass) IMPLEMENTS Type TypeList
					;
		
TypeList ::= (TypeListClass) TypeList COMMA Type
			|
			(NoTypeListClass) /* epsilon */
			;
			
OptionalMethodDeclList ::= (OptionalMethodDeclarationListClass) LEFT_BRACE MethodDeclList RIGHT_BRACE
						|
						(NoOptionalMethodDeclarationListClass) /* epsilon */
						;
								
MethodDeclList ::= (MethodDeclarationListClass) MethodDeclList MethodDecl
			|
			(NoMethodDeclarationListClass)/* epsilon */
			;


InterfaceDecl ::= (InterfaceDeclarationClass) INTERFACE IDENTIFIER LEFT_BRACE InterfaceMethodDeclList RIGHT_BRACE
				;

InterfaceMethodDeclList ::= (InterfaceMethodDeclListClass) InterfaceMethodDeclList InterfaceMethodDecl
						|
						(NoInterfaceMethodDeclListClass) /* epsilon */
						;

InterfaceMethodDecl ::= (InterfaceMethodDeclarationClass) ReturnType IDENTIFIER LEFT_PARENTHESIS OptionalFormPars RIGHT_PARENTHESIS SEPARATOR
					;

MethodDecl ::= (MethodDecl) ReturnType IDENTIFIER LEFT_PARENTHESIS OptionalFormPars RIGHT_PARENTHESIS VarDeclList LEFT_BRACE StatementList RIGHT_BRACE
			;
			
ReturnType ::= (ReturnTypeClass) Type
			|
			(NoReturnTypeClass) VOID
			;

OptionalFormPars ::= (OptionalFormParsClass) FormPars
				|
				(NoOptionalFormParsClass) /* epsilon */
				;

VarDeclList ::= (VariableDeclList) VarDeclList VarDecl
			|
			(VariableDeclListNO) /* epsilon */
			;
				
FormPars ::= (FromParamsClass) Type VarName TypeIdentBracketsList
			;
			
OptionalBrackets ::= (Brackets) LEFT_BRACKET RIGHT_BRACKET
				|
				(BracketsNO) /* epsilon */
				;

TypeIdentBracketsList ::= (TypeIdentBracketsListClass) TypeIdentBracketsList COMMA Type VarName
					|
					(NoTypeIdentBracketsListClass) /* epsilon */
					;

Type ::= (TypeInt) INT
		|
		(TypeBool) BOOL
		|
		(TypeChar) CHAR
		|
		(TypeCustom) IDENTIFIER:typeName
		;

Statement ::= (StatementDesignatorClass) DesignatorStatement SEPARATOR
			|
			(StatementIfClass) IfStatement 
			|
			(StatementForClass) ForStatement
			|
			(StatementBreakClass) BREAK SEPARATOR
			|
			(StatementContinueClass) CONTINUE SEPARATOR
			|
			(StatementReturnClass) RETURN OptionalExpr SEPARATOR
			|
			(StatementReadClass) READ LEFT_PARENTHESIS Designator RIGHT_PARENTHESIS SEPARATOR
			|
			(StatementPrintClass) PRINT LEFT_PARENTHESIS Expr OptionalCommaNumConst RIGHT_PARENTHESIS SEPARATOR
			|
			(StatementStatementListClass) LEFT_BRACE StatementList RIGHT_BRACE
			;

IfStatement ::=  (IfStatementClass) IF LEFT_PARENTHESIS Condition RIGHT_PARENTHESIS Statement OptionalElse
			;
		
OptionalElse ::= (OptionalElseClass) ELSE Statement
				|
				(NoOptionalElseClass) /* epsilon */
				;
			
ForStatement ::= (ForStatementClass) FOR LEFT_PARENTHESIS OptionalDesignatorStatement SEPARATOR OptionalCondition SEPARATOR OptionalDesignatorStatement RIGHT_PARENTHESIS Statement
			;
			
OptionalCondition ::= (OptionalConditionClass) Condition 
					|
					(NoOptionalConditionClass) /* epsilon */
					;
			
OptionalDesignatorStatement ::= (OptionalDesignatorStatementClass) DesignatorStatement
							|
							(NoOptionalDesignatorStatementClass) /* epsilon */
							;
						
OptionalExpr ::= (OptionalExprClass) Expr
				|
				(NoOptionalExprClass) /* epsilon */
				;
	
OptionalCommaNumConst ::= (OptionalComaNumberConstClass) COMMA INT_VALUE
						|
						(NoOptionalComaNumberConstClass) /* espilon */
						;		
			
StatementList ::= (StatementListClass) StatementList Statement
				|
				(NoStatementListClass) /* epsilon */
				;

DesignatorStatement ::= (DesignatorStatementClass) Designator DesignatorStatementOption
					;
					
DesignatorStatementOption ::= (DesignatorStatementAssignOptionClass) Assignop Expr
							|
							(DesignatorStatementParamsOptionClass) LEFT_PARENTHESIS OptionalActPars RIGHT_PARENTHESIS
							|
							(DesignatorStatementIncrementOptionClass) INCREMENT
							|
							(DesignatorStatementDecrementOptionClass) DECREMENT
							;												

ActPars ::= (ActParamsClass) Expr ExprList
		;
		
ExprList ::= (ExpressionListClass) ExprList COMMA Expr
			|
			(NoExpressionListClass) /* epsilon */
			;

Condition ::= (ConditionClass) CondTerm OrCondFactList
			;
			
OrCondFactList ::= (OrConditionFactListClass) OrCondFactList OR CondFact
				|
				(NoOrConditionFactListClass) /* epsilon */
				;				

CondTerm ::= (ConditionTermClass) CondFact AndCondFactList
			;
			
AndCondFactList ::= (AndConditionFactListClass) AndCondFactList AND CondFact
				|
				(NoAndConditionFactListClass) /* epsilon */
				;	

CondFact ::= (ConditionFactClass) Expr OptionalRelopExpr
		;
		
OptionalRelopExpr ::= (OptionalRelopExprClassClass) Relop Expr
					|
					(NoOptionalRelopExprClassClass) /* epsilon */
					;


Expr ::= (ExpressionClass) OptionalMinus Term AddopTermList
		;
		
OptionalMinus ::= (OptionalSubtractClass) SUBTRACT 
				|
				(NoOptionalSubtractClass) /* epsilon */
				;

AddopTermList ::= (AddOperationtermListClass) AddopTermList Addop Term
				|
				(NoAddOperationtermListClass)/* epilon */
				;

Term ::= (TermClass) Factor MulopFactorList
		;

MulopFactorList ::= (MulOperationFactorListClass) MulopFactorList Mulop Factor
				|
				(NoMulOperationFactorListClass) /* epilon */
				;

Factor ::= (FactorDesignatorClass) DesignatorFactor
		|
		(FactorIntClass) INT_VALUE
		|
		(FactorCharClass) CHAR_VALUE
		|
		(FactorBoolClass) BOOL_VALUE
		|
		(FactorNewClass) NewFactor
		|
		(FactorNullClass) NULL
		|
		(FactorExpressionClass) LEFT_PARENTHESIS Expr RIGHT_PARENTHESIS
		;
		
DesignatorFactor ::= (DesignatorFactorClass) Designator OptionalDesignatorCallParams
				;
				
OptionalDesignatorCallParams ::= (OptionalDesignatorCallParamsClass) DesignatorCallParams
								|
								(NoOptionalDesignatorCallParamsClass) /* epsilon */
								;
	
DesignatorCallParams ::= (DesignatorCallParamsClass) LEFT_PARENTHESIS OptionalActPars RIGHT_PARENTHESIS
					;
					
OptionalActPars ::= (OptionalActParsClass) ActPars
				|
				(NoOptionalActParsClass) /* epsilon */
				;
		
NewFactor ::= (NewFactorClass) NEW Type OptionalArraySelector
			;

OptionalArraySelector ::= (OptionalArraySelectorClass) ArraySelector
						|
						(NoOptionalArraySelectorClass) /* epsilon */
						;

Designator ::= (DesignatorClass) IDENTIFIER DesignatorSelectorList
			;
			
DesignatorSelectorList ::= (DesignatorSelectorListClass) DesignatorSelectorList DesignatorSelector
						|
						(NoDesignatorSelectorListClass) /* epsilon */
						;
						
DesignatorSelector ::= (DesignatorSelectorPointClass) PointSelector
					|
					(DesignatorSelectorArrayClass) ArraySelector
					;
	
PointSelector ::= (PointSelectorClass) POINT IDENTIFIER
				;

ArraySelector ::= (ArraySelectorClass) LEFT_BRACKET Expr RIGHT_BRACKET
				;

Assignop ::= (AssignOperationClass) ASSIGN 	
			;

Relop ::= (RelopEqClass) EQUAL
		|
		(RelopNeqClass) NOT_EQUAL
		|
		(RelopGtClass) GREATER
		|
		(RelopGeClass) GREATER_EQUAL
		|
		(RelopLtClass) LESS
		|
		(RelopLeClass) LESS_EQUAL
		;

Addop ::= (AddopPlusClass) ADD
		|
		(AddOpMinusClass) SUBTRACT
		;

Mulop ::= (MulopMullClass) MULTIPLY 
		|
		(MulopDivClass) DIVIDE
		|
		(MulopModClass) MODULO
		;


